import os
import sys
import time
import traceback
from pathlib import Path
from typing import Any, Optional, Callable, Union, Dict, List, Tuple, Set
from tkinter import filedialog
from tkinter import messagebox as MB
from fpowerkit import Grid as PowerGrid
from feasytools import RangeList, SegFunc, OverrideFunc, ConstFunc, PDUniform
import xml.etree.ElementTree as ET
from fgui.evtq import EventQueue
import v2sim
from v2sim import *
from .langhelper import add_lang_menu
from .view import *
from .controls import ScrollableTreeView, empty_postfunc, EditMode, LogItemPad, PropertyPanel, PDFuncEditor, ALWAYS_ONLINE, SelectItemDialog
from .network import NetworkPanel, OAfter

AMAP_KEY_FILE = "amap_key.txt"
DEFAULT_GRID = '<grid Sb="1MVA" Ub="10.0kV" model="ieee33" fixed-load="false" grid-repeat="1" load-repeat="8" />'

def showerr(msg:str):
    MB.showerror(_L["MB_ERROR"], msg)

_L = CustomLocaleLib.LoadFromFolder("resources/gui_main")

SIM_YES = "YES"
SIM_NO = "NO"
LOAD_FCS = "Fast CS"
LOAD_SCS = "Slow CS"
LOAD_NET = "Network"
LOAD_CSCSV = "CS CSV"
LOAD_PLG = "Plugins"
LOAD_GEN = "Instance"
EXT_COMP = "external_components"

    
class PluginEditor(ScrollableTreeView):
    def __addgetter(self):
        # 获取第1列所有值
        plgs_exist = set(self.item(i, 'values')[0] for i in self.get_children())
        plgs = [[x] for x in self.plg_pool.GetAllPlugins() if x not in plgs_exist]
        f = SelectItemDialog(plgs, _L["SIM_SELECTPLG"], [("Name", _L["PLG_NAME"])])
        f.wait_window()
        if f.selected_item is None:
            return None
        plgname = f.selected_item[0]
        plgtype = self.plg_pool.GetPluginType(plgname)
        assert issubclass(plgtype, PluginBase)
        self.setCellEditMode(plgname, "Extra", ConfigItem("Extra", EditMode.PROP, "Extra properties", prop_config=plgtype.ElemShouldHave()))
        return [plgname, 300, SIM_YES, ALWAYS_ONLINE, plgtype.ElemShouldHave().default_value_dict()]
    
    def GetEnabledPlugins(self):
        enabled_plg = []
        for i in self.get_children():
            if self.item(i, 'values')[2] == SIM_YES:
                enabled_plg.append(self.item(i, 'values')[0])
        return enabled_plg
            
    def __init__(self, master, onEnabledSet:Callable[[Tuple[Any,...], str], None] = empty_postfunc, **kwargs):
        super().__init__(master, True, True, True, True, self.__addgetter, **kwargs)
        self.sta_pool = StaPool()
        self.plg_pool = PluginPool()
        if Path(EXT_COMP).exists():
            load_external_components(EXT_COMP, self.plg_pool, self.sta_pool)
        else:
            print(f"Warning: external components folder '{EXT_COMP}' not found.")
        self["show"] = 'headings'
        self["columns"] = ("Name", "Interval", "Enabled", "Online", "Extra")
        self.column("Name", width=120, stretch=NO)
        self.column("Interval", width=100, stretch=NO)
        self.column("Enabled", width=100, stretch=NO)
        self.column("Online", width=200, stretch=NO)
        self.column("Extra", width=200, stretch=YES)
        self.heading("Name", text=_L["SIM_PLGNAME"])
        self.heading("Interval", text=_L["SIM_EXEINTV"])
        self.heading("Enabled", text=_L["SIM_ENABLED"])
        self.heading("Online", text=_L["SIM_PLGOL"])
        self.heading("Extra", text=_L["SIM_PLGPROP"])
        self.setColEditMode("Interval", ConfigItem("Interval", EditMode.SPIN, "Time interval", spin_range=(1, 86400)))
        self.setColEditMode("Enabled", ConfigItem("Enabled", EditMode.COMBO, "Enabled or not", combo_values=[SIM_YES, SIM_NO]), post_func=onEnabledSet)
        self.setColEditMode("Online", ConfigItem("Online", EditMode.RANGELIST, "Online time ranges", rangelist_hint=True))
        self.setColEditMode("Extra", ConfigItem("Extra", EditMode.DISABLED, "Extra properties"))
        self.__onEnabledSet = onEnabledSet
    
    def add(self, plg_name:str, interval:Union[int, str], enabled:str, online:Union[RangeList, str], extra:Dict[str, Any]):
        new_line = (plg_name, interval, enabled, online, str(extra))
        self.insert("", "end", values=new_line)
        plg_type = self.plg_pool.GetPluginType(plg_name)
        assert issubclass(plg_type, PluginBase)
        self.setCellEditMode(plg_name, "Extra", ConfigItem("Extra", EditMode.PROP, "Extra properties", prop_config=plg_type.ElemShouldHave()))
        self.__onEnabledSet(new_line, plg_name)
    
    def is_enabled(self, plg_name:str):
        for i in self.get_children():
            if self.item(i, 'values')[0] == plg_name:
                return self.item(i, 'values')[2] == SIM_YES
        return False       
        

class CSEditorGUI(Frame):
    def __init__(self, master, generatorFunc, canV2g:bool, file:str="", **kwargs):
        super().__init__(master, **kwargs)

        self._Q = EventQueue(self)
        self._Q.register("loaded", lambda: None)
        
        self.gf = generatorFunc
        if file:
            self.file = file
        else:
            self.file = ""
        
        self.tree = ScrollableTreeView(self, allowSave=True) 
        self.tree['show'] = 'headings'
        if canV2g:
            self.csType = SCS
            self.tree["columns"] = ("Node", "Slots", "Bus", "x", "y", "Online", "MaxPc", "MaxPd", "PriceBuy", "PriceSell", "PcAlloc", "PdAlloc")
        else:
            self.csType = FCS
            self.tree["columns"] = ("Node", "Slots", "Bus", "x", "y", "Online", "MaxPc", "PriceBuy", "PcAlloc")
        self.tree.column("Node", width=120, stretch=NO)
        self.tree.column("Slots", width=90, stretch=NO)
        self.tree.column("Bus", width=80, stretch=NO)
        self.tree.column("x", width=60, stretch=NO)
        self.tree.column("y", width=60, stretch=NO)
        self.tree.column("Online", width=100, stretch=NO)
        self.tree.column("MaxPc", width=130, stretch=NO)
        self.tree.column("PriceBuy", width=120, stretch=YES)
        if canV2g:
            self.tree.column("MaxPd", width=130, stretch=NO)
            self.tree.column("PriceSell", width=120, stretch=YES)
            self.tree.column("PcAlloc", width=80, stretch=NO)
            self.tree.column("PdAlloc", width=80, stretch=NO)
        
        self.tree.heading("Node", text=_L["CSE_NODE"])
        self.tree.heading("Slots", text=_L["CSE_SLOTS"])
        self.tree.heading("Bus", text=_L["CSE_BUS"])
        self.tree.heading("x", text=_L["CSE_X"])
        self.tree.heading("y", text=_L["CSE_Y"])
        self.tree.heading("Online", text=_L["CSE_OFFLINE"])
        self.tree.heading("MaxPc", text=_L["CSE_MAXPC"])
        self.tree.heading("PriceBuy", text=_L["CSE_PRICEBUY"])
        self.tree.heading("PcAlloc", text=_L["CSE_PCALLOC"])

        self.tree.setColEditMode("Node", EditMode.entry())
        self.tree.setColEditMode("Slots", EditMode.spin(0, 100))
        self.tree.setColEditMode("Bus", EditMode.entry())
        self.tree.setColEditMode("x", EditMode.entry())
        self.tree.setColEditMode("y", EditMode.entry())
        self.tree.setColEditMode("Online", EditMode.rangelist(hint=True))
        self.tree.setColEditMode("MaxPc", EditMode.spin(0, 1000))
        self.tree.setColEditMode("PriceBuy", EditMode.segfunc())
        self.tree.setColEditMode("PcAlloc", EditMode.combo(values=["Average", "Prioritized"]))

        if canV2g:
            self.tree.heading("PriceSell", text=_L["CSE_PRICESELL"])
            self.tree.heading("MaxPd", text=_L["CSE_MAXPD"])
            self.tree.heading("PdAlloc", text=_L["CSE_PDALLOC"])
            self.tree.setColEditMode("PriceSell", EditMode.segfunc())
            self.tree.setColEditMode("MaxPd", EditMode.spin(0, 1000))
            self.tree.setColEditMode("PdAlloc", EditMode.combo(values=["Average"]))
        self.tree.pack(fill="both", expand=True)

        self.panel2 = Frame(self)
        self.btn_find = Button(self.panel2, text=_L["BTN_FIND"], command=self._on_btn_find_click)
        self.btn_find.pack(fill="x", side='right', anchor='e', expand=False)
        self.entry_find = Entry(self.panel2)
        self.entry_find.pack(fill="x", side='right', anchor='e',expand=False)
        self.lb_cnt = Label(self.panel2, text=_L["LB_COUNT"].format(0))
        self.lb_cnt.pack(fill="x", side='left', anchor='w', expand=False)
        self.panel2.pack(fill="x")

        self.gens = LabelFrame(self, text=_L["CS_GEN"])
        self.gens.pack(fill="x", expand=False)

        self.useMode = IntVar(self, 0)
        self.group_use = LabelFrame(self.gens, text=_L["CS_MODE"])
        self.rb_useAll = Radiobutton(self.group_use, text=_L["CS_USEALL"], value=0, variable=self.useMode, command=self._useModeChanged)
        self.rb_useAll.grid(row=0,column=0,padx=3,pady=3,sticky="w")
        self.rb_useSel = Radiobutton(self.group_use, text=_L["CS_SELECTED"], value=1, variable=self.useMode, command=self._useModeChanged)
        self.rb_useSel.grid(row=0,column=1,padx=3,pady=3,sticky="w")
        self.entry_sel = Entry(self.group_use, state="disabled")
        self.entry_sel.grid(row=0,column=2,padx=3,pady=3,sticky="w")
        self.rb_useRandN = Radiobutton(self.group_use, text=_L["CS_RANDOM"], value=2, variable=self.useMode, command=self._useModeChanged)
        self.rb_useRandN.grid(row=0,column=3,padx=3,pady=3,sticky="w")
        self.entry_randN = Entry(self.group_use, state="disabled")
        self.entry_randN.grid(row=0,column=4,padx=3,pady=3,sticky="w")
        self.group_use.grid(row=2,column=0,padx=3,pady=3,sticky="nesw")

        self.use_cscsv = IntVar(self, 0)
        self.group_src = LabelFrame(self.gens, text=_L["CS_SRC"])
        self.rb_rnet = Radiobutton(self.group_src, text=_L["CS_USENODES"], value=0, variable=self.use_cscsv)
        self.rb_rnet.grid(row=0,column=0,padx=3,pady=3,sticky="w")
        self.rb_cscsv = Radiobutton(self.group_src, text=_L["CS_USECSV"], value=1, variable=self.use_cscsv, state="disabled")
        self.rb_cscsv.grid(row=0,column=1,padx=3,pady=3,sticky="w")
        self.rb_poly = Radiobutton(self.group_src, text=_L["CS_USEPOLY"], value=2, variable=self.use_cscsv,state="disabled")
        self.rb_poly.grid(row=0,column=2,padx=3,pady=3,sticky="w")
        self.group_src.grid(row=1,column=0,padx=3,pady=3,sticky="nesw")

        self.fr = Frame(self.gens)
        self.lb_slots = Label(self.fr, text=_L["CS_SLOTS"])
        self.lb_slots.grid(row=0,column=0,padx=3,pady=3,sticky="w")
        self.entry_slots = Entry(self.fr)
        self.entry_slots.grid(row=0,column=1,padx=3,pady=3,sticky="w")
        self.entry_slots.insert(0, "10")
        self.lb_seed = Label(self.fr, text=_L["CS_SEED"])
        self.lb_seed.grid(row=0,column=2,padx=3,pady=3,sticky="w")
        self.entry_seed = Entry(self.fr)
        self.entry_seed.grid(row=0,column=3,padx=3,pady=3,sticky="w")
        self.entry_seed.insert(0, "0")
        self.fr.grid(row=0,column=0,padx=3,pady=3,sticky="nesw")
        
        self.pbuy = IntVar(self, 1)
        self.group_pbuy = LabelFrame(self.gens, text=_L["CS_PRICEBUY"])
        self.rb_pbuy0 = Radiobutton(self.group_pbuy, text=_L["CS_PB5SEGS"], value=0, variable=self.pbuy, command=self._pBuyChanged)
        self.rb_pbuy0.grid(row=0,column=0,padx=3,pady=3,sticky="w")
        self.rb_pbuy1 = Radiobutton(self.group_pbuy, text=_L["CS_PBFIXED"], value=1, variable=self.pbuy, command=self._pBuyChanged)
        self.rb_pbuy1.grid(row=0,column=1,padx=3,pady=3,sticky="w")
        self.entry_pbuy = Entry(self.group_pbuy)
        self.entry_pbuy.insert(0, "1.0")
        self.entry_pbuy.grid(row=0,column=2,padx=3,pady=3,sticky="w")
        self.group_pbuy.grid(row=3,column=0,padx=3,pady=3,sticky="nesw")

        self.psell = IntVar(self, 1)
        self.group_psell = LabelFrame(self.gens, text=_L["CS_PRICESELL"])
        self.rb_psell0 = Radiobutton(self.group_psell, text=_L["CS_PB5SEGS"], value=0, variable=self.psell, command=self._pSellChanged)
        self.rb_psell0.grid(row=0,column=0,padx=3,pady=3,sticky="w")
        self.rb_psell1 = Radiobutton(self.group_psell, text=_L["CS_PBFIXED"], value=1, variable=self.psell, command=self._pSellChanged)
        self.rb_psell1.grid(row=0,column=1,padx=3,pady=3,sticky="w")
        self.entry_psell = Entry(self.group_psell)
        self.entry_psell.insert(0, "1.5")
        self.entry_psell.grid(row=0,column=2,padx=3,pady=3,sticky="w")
        self.group_psell.grid(row=4,column=0,padx=3,pady=3,sticky="nesw")

        self.busMode = IntVar(self, 0)
        self.group_bus = LabelFrame(self.gens, text=_L["CS_BUSMODE"])
        self.rb_busGrid = Radiobutton(self.group_bus, text=_L["CS_BUSBYPOS"], value=0, variable=self.busMode, command=self._busModeChanged)
        self.rb_busGrid.grid(row=0,column=0,padx=3,pady=3,sticky="w")
        self.rb_busAll = Radiobutton(self.group_bus, text=_L["CS_BUSUSEALL"], value=1, variable=self.busMode, command=self._busModeChanged)
        self.rb_busAll.grid(row=0,column=1,padx=3,pady=3,sticky="w")
        self.rb_busSel = Radiobutton(self.group_bus, text=_L["CS_BUSSELECTED"], value=2, variable=self.busMode, command=self._busModeChanged)
        self.rb_busSel.grid(row=0,column=2,padx=3,pady=3,sticky="w")
        self.entry_bussel = Entry(self.group_bus, state="disabled")
        self.entry_bussel.grid(row=0,column=3,padx=3,pady=3,sticky="w")
        self.rb_busRandN = Radiobutton(self.group_bus, text=_L["CS_BUSRANDOM"], value=3, variable=self.busMode, command=self._busModeChanged)
        self.rb_busRandN.grid(row=0,column=4,padx=3,pady=3,sticky="w")
        self.entry_busrandN = Entry(self.group_bus, state="disabled")
        self.entry_busrandN.grid(row=0,column=5,padx=3,pady=3,sticky="w")
        self.group_bus.grid(row=5,column=0,padx=3,pady=3,sticky="nesw")

        self.btn_regen = Button(self.gens, text=_L["CS_BTN_GEN"], command=self.generate)
        self.btn_regen.grid(row=6,column=0,padx=3,pady=3,sticky="w")
        self.tree.setOnSave(self.save())

        self.cslist:List[CS] = []
    
    @property
    def saved(self):
        return self.tree.saved
    
    def save(self):
        def mkFunc(s:str):
            try:
                return ConstFunc(float(s))
            except:
                return SegFunc(eval(s))
            
        def _save(data:List[tuple]):
            if not self.file: return False
            assert len(self.cslist) == len(data)
            with open(self.file, "w") as f:
                f.write(f"<?xml version='1.0' encoding='utf-8'?>\n<root>\n")
                if self.csType == FCS:
                    for i, d in enumerate(data):
                        assert len(d) == 9
                        name, slots, bus, x, y, ol, maxpc, pbuy, pcalloc = d
                        c = self.cslist[i]
                        c._name = name
                        c._slots = slots
                        c._bus = bus
                        c._x = float(x)
                        c._y = float(y)
                        c._pc_lim1 = float(maxpc) / 3600
                        if ol == ALWAYS_ONLINE: ol = "[]"
                        c._offline = RangeList(eval(ol))
                        c._pbuy = OverrideFunc(mkFunc(pbuy))
                        f.write(c.to_xml())
                        f.write("\n")
                else:
                    for i, d in enumerate(data):
                        assert len(d) == 12
                        name, slots, bus, x, y, ol, maxpc, maxpd, pbuy, psell, pcalloc, pdalloc = d
                        c = self.cslist[i]
                        c._name = name
                        c._slots = slots
                        c._bus = bus
                        c._x = float(x)
                        c._y = float(y)
                        c._pc_lim1 = float(maxpc) / 3600
                        c._pd_lim1 = float(maxpd) / 3600
                        if ol == ALWAYS_ONLINE: ol = "[]"
                        c._offline = RangeList(eval(ol))
                        c._pbuy = OverrideFunc(mkFunc(pbuy))
                        c._psell = OverrideFunc(mkFunc(psell))
                        c._pc_alloc_str = pcalloc
                        c._pd_alloc_str = pdalloc
                        f.write(c.to_xml())
                        f.write("\n")
                f.write("</root>")
            return True
        return _save

    def FindCS(self, edge:str):
        for item in self.tree.get_children():
            if self.tree.item(item, 'values')[0] == edge:
                self.tree.tree.selection_set(item)
                self.tree.tree.focus(item)
                self.tree.tree.see(item)
                break
    
    def _on_btn_find_click(self):
        self.FindCS(self.entry_find.get())
    
    def setPoly(self, val:bool):
        if not val:
            self.rb_poly.configure(state="disabled")
            if self.use_cscsv.get() == 2:
                self.use_cscsv.set(0)
        else:
            self.rb_poly.configure(state="normal")
    
    def setCSCSV(self, val:bool):
        if not val:
            self.rb_cscsv.configure(state="disabled")
            if self.use_cscsv.get() == 1:
                self.use_cscsv.set(0)
        else:
            self.rb_cscsv.configure(state="normal")

    def _pBuyChanged(self):
        v = self.pbuy.get()
        if v == 0:
            self.entry_pbuy.config(state="disabled")
        else:
            self.entry_pbuy.config(state="normal")
    
    def _pSellChanged(self):
        v = self.psell.get()
        if v == 0:
            self.entry_psell.config(state="disabled")
        else:
            self.entry_psell.config(state="normal")
    
    def _useModeChanged(self):
        v = self.useMode.get()
        if v == 0:
            self.entry_sel.config(state="disabled")
            self.entry_randN.config(state="disabled")
        elif v == 1:
            self.entry_sel.config(state="normal")
            self.entry_randN.config(state="disabled")
        else:
            self.entry_sel.config(state="disabled")
            self.entry_randN.config(state="normal")
    
    def _busModeChanged(self):
        v = self.busMode.get()
        if v == 0 or v == 1:
            self.entry_bussel.config(state="disabled")
            self.entry_busrandN.config(state="disabled")
        elif v == 2:
            self.entry_bussel.config(state="normal")
            self.entry_busrandN.config(state="disabled")
        else:
            self.entry_bussel.config(state="disabled")
            self.entry_busrandN.config(state="normal")

    def generate(self):
        try:
            seed = int(self.entry_seed.get())
        except:
            showerr("Invalid seed")
            return
        try:
            slots = int(self.entry_slots.get())
        except:
            showerr("Invalid slots")
            return
        mode = "fcs" if self.csType == FCS else "scs"
        if self.useMode.get() == 0:
            cs = ListSelection.ALL
            csCount = -1
            givenCS = []
        elif self.useMode.get() == 1:
            cs = ListSelection.GIVEN
            csCount = -1
            try:
                givenCS = self.entry_sel.get().split(',')
            except:
                showerr("Invalid given CS")
                return
            if len(givenCS) == 0 or len(givenCS) == 1 and givenCS[0] == "":
                showerr("No given CS")
                return
        else:
            cs = ListSelection.RANDOM
            try:
                csCount = int(self.entry_randN.get())
            except:
                showerr("Invalid random N of CS")
                return
            givenCS = []
        use_grid = False
        busCount = -1
        givenbus = []
        if self.busMode.get() == 0:
            use_grid = True
            bus = ListSelection.ALL
        elif self.busMode.get() == 1:
            bus = ListSelection.ALL
        elif self.busMode.get() == 2:
            bus = ListSelection.GIVEN
            try:
                givenbus = self.entry_bussel.get().split(',')
            except:
                showerr("Invalid given bus")
                return
            if len(givenbus) == 0 or len(givenbus) == 1 and givenbus[0] == "":
                showerr("No given bus")
                return
        else:
            bus = ListSelection.RANDOM
            try:
                busCount = int(self.entry_randN.get())
            except:
                showerr("Invalid random N of bus")
                return
        
        if self.pbuy.get() == 0:
            pbuyM = PricingMethod.RANDOM
            pbuy = 1.0
        else:
            pbuyM = PricingMethod.FIXED
            try:
                pbuy = float(self.entry_pbuy.get())
            except:
                showerr("Invalid price buy")
                return
        if self.csType == FCS:
            if self.psell.get() == 0:
                psellM = PricingMethod.RANDOM
                psell = 0
            else:
                psellM = PricingMethod.FIXED
                try:
                    psell = float(self.entry_psell.get())
                except:
                    showerr("Invalid price sell")
                    return
        else:
            psellM = PricingMethod.FIXED
            psell = 0
        self.btn_regen.config(state=DISABLED)
        self.gf(self, self.use_cscsv.get(), seed = seed, mode = mode, slots = slots,
                bus = bus, busCount = busCount, givenBus = givenbus,
                cs = cs, csCount = csCount, givenCS = givenCS, 
                priceBuyMethod = pbuyM, priceBuy = pbuy, priceSellMethod = psellM, 
                priceSell = psell, hasSell = self.csType == SCS, use_grid = use_grid)
    
    def load(self, file:str):
        self._Q.submit("loaded", self.__load, file)
            
    def clear(self):
        self.tree.clear()
        self.lb_cnt.config(text=_L["LB_COUNT"].format(0))
    
    def __load(self, file:str):
        try:
            self.cslist = LoadCSList(file, self.csType)
        except Exception as e:
            showerr(f"Error loading {file}: {e}")
            return
        self.file = file
        self.tree.clear()
        self.lb_cnt.config(text=_L["LB_COUNT"].format(len(self.cslist)))
        if self.csType == FCS:
            for cs in self.cslist:
                ol = str(cs._offline) if len(cs._offline)>0 else ALWAYS_ONLINE
                v = (cs.name, cs.slots, cs.bus, cs._x, cs._y, ol, cs._pc_lim1 * 3600, cs.pbuy, cs._pc_alloc_str)
                self._Q.delegate(self.tree.insert, "", "end", values=v)
        else:
            for cs in self.cslist:
                assert isinstance(cs, SCS)
                ol = str(cs._offline) if len(cs._offline)>0 else ALWAYS_ONLINE
                v = (cs.name, cs.slots, cs.bus, cs._x, cs._y, ol, cs._pc_lim1 * 3600, cs._pd_lim1 * 3600, 
                            cs.pbuy, cs._psell, cs._pc_alloc_str, cs._pd_alloc_str)
                self._Q.delegate(self.tree.insert, "", "end", values=v)
    
    
class CSCSVEditor(Frame):
    def __init__(self, master, down_worker, file:str="", **kwargs):
        super().__init__(master, **kwargs)

        self._Q = EventQueue(self)
        self._Q.register("loaded", lambda: None)

        if file:
            self.file = file
        else:
            self.file = ""
        self.down_wk = down_worker
        self.tree = ScrollableTreeView(self) 
        self.tree['show'] = 'headings'
        self.tree["columns"] = ("ID", "Address", "X", "Y")
        self.tree.column("ID", width=120, stretch=NO)
        self.tree.column("X", width=100, stretch=NO)
        self.tree.column("Y", width=100, stretch=NO)
        self.tree.column("Address", width=180, stretch=YES)
        
        self.tree.heading("ID", text=_L["CSCSV_ID"])
        self.tree.heading("X", text=_L["CSCSV_X"])
        self.tree.heading("Y", text=_L["CSCSV_Y"])
        self.tree.heading("Address", text=_L["CSCSV_ADDR"])
        self.tree.pack(fill="both", expand=True)

        self.lb_cnt = Label(self, text=_L["LB_COUNT"].format(0))
        self.lb_cnt.pack(fill="x", expand=False)

        self.panel = Frame(self)
        self.panel.pack(fill="x", expand=False)
        self.btn_down = Button(self.panel, text=_L["CSCSV_DOWNLOAD"], command=self.down)
        self.btn_down.grid(row=0,column=0,padx=3,pady=3,sticky="w")
        self.lb_amapkey = Label(self.panel, text=_L["CSCSV_KEY"])
        self.lb_amapkey.grid(row=0, column=1, padx=3, pady=3, sticky="w")
        self.entry_amapkey = Entry(self.panel, width=50)
        self.entry_amapkey.grid(row=0, column=2, columnspan=2, padx=3, pady=3, sticky="w")

        if Path(AMAP_KEY_FILE).exists():
            with open(AMAP_KEY_FILE, "r") as f:
                self.entry_amapkey.insert(0, f.read().strip())
        
    def down(self):
        if MB.askyesno(_L["CSCSV_CONFIRM_TITLE"], _L["CSCSV_CONFIRM"]):
            with open(AMAP_KEY_FILE, "w") as f:
                f.write(self.entry_amapkey.get().strip())
            self.down_wk()
    
    def __load(self, file:str):
        try:
            with open(file, "r") as f:
                f.readline()
                lines = f.readlines()
        except Exception as e:
            showerr(f"Error loading {file}: {e}")
            return
        self.file = file
        self.lb_cnt.config(text=_L["LB_COUNT"].format(len(lines) - 1))
        self.tree.clear()
        for i, cs in enumerate(lines, start=2):
            vals = cs.strip().split(',')
            if len(vals) != 4:
                print(f"Invalid line {i} in CS CSV:", cs)
            self._Q.delegate(self.tree.insert, "", "end", values=tuple(vals))

    def load(self, file:str):
        self._Q.submit("loaded", self.__load, file)
    
    def clear(self):
        self.lb_cnt.config(text=_L["LB_COUNT"].format(0))
        self.tree.clear()


class LoadingBox(Toplevel):
    def __init__(self, items:List[str], parentQ:EventQueue, **kwargs):
        super().__init__(None, **kwargs)
        self._pQ = parentQ
        self.title("Loading...")
        self.geometry("400x300")
        self.attributes("-topmost", True)
        self.cks:List[Label]=[]
        self.dkt:Dict[str,int]={}
        self.columnconfigure(0, weight=1)
        self.columnconfigure(1, weight=1)
        for i, t in enumerate(items):
            Label(self, text=t).grid(column=0,row=i)
            self.cks.append(Label(self, text="..."))
            self.cks[-1].grid(column=1,row=i)
            self.dkt[t]=i
            self.rowconfigure(i, weight=1)
        self._closed = False
    
    def setText(self, itm:str, val:str):
        if self._closed: return
        self.cks[self.dkt[itm]].configure(text=val)
        for x in self.cks:
            if x['text'] != _L['DONE']: break
        else:
            self._closed = True
            self._pQ.delegate(self.destroy)
    

class MainBox(Tk):
    def __OnPluginEnabledSet(self, itm:Tuple[Any,...]=(), v:str=""):
        plgs = self.sim_plglist.GetEnabledPlugins()
        self.sim_statistic.check_by_enabled_plugins(plgs)
    
    def __init__(self, to_open:str = ""):
        super().__init__()
        self._Q = EventQueue(self)
        
        def proc_exception(e: Optional[Exception] = None):
            if e:
                self.setStatus(f"Error: {e}")
                showerr(f"Error: {e}")
            else:
                self.setStatus(_L["STA_READY"])
       
        def on_CSGendone(ctl: CSEditorGUI, e: Optional[Exception] = None):
            ctl.btn_regen.config(state=NORMAL)
            proc_exception(e)
        
        self._Q.register("CSGenDone", on_CSGendone)

        def on_VehGenDone(e: Optional[Exception] = None):
            self.btn_genveh.config(state = NORMAL)
            proc_exception(e)
        
        self._Q.register("VehGenDone", on_VehGenDone)

        def on_CSCSVDownloadDone(e: Optional[Exception] = None):
            proc_exception(e)
        
        self._Q.register("CSCSVDownloadDone", on_CSCSVDownloadDone)

        def on_TrafficGenLoaded():
            self._ldfrm.setText(LOAD_GEN, _L['DONE'])
        self._Q.register("TrafficGenLoaded", on_TrafficGenLoaded)

        
        self._Q.register("cvnetloaded", self.on_cvnet_loaded)

        self.folder:str = to_open
        self.state:Optional[FileDetectResult] = None
        self.tg:Optional[TrafficGenerator] = None
        self._win()

        self.menu = Menu(self)
        self.menuFile = Menu(self.menu, tearoff=False)
        self.menu.add_cascade(label=_L["MENU_PROJ"], menu=self.menuFile)
        self.menuFile.add_command(label=_L["MENU_OPEN"], command=self.openFolder, accelerator='Ctrl+O')
        self.bind("<Control-o>", lambda e: self.openFolder())
        self.menuFile.add_command(label=_L["MENU_SAVEALL"], command=self.save, accelerator="Ctrl+S")
        self.bind("<Control-s>", lambda e: self.save())
        self.menuFile.add_separator()
        self.menuFile.add_command(label=_L["MENU_EXIT"], command=self.onDestroy, accelerator='Ctrl+Q')
        self.bind("<Control-q>", lambda e: self.onDestroy())
        add_lang_menu(self.menu)
        self.config(menu=self.menu)
        self.rowconfigure(0, weight=1)
        self.columnconfigure(1, weight=1)

        self.panel_info = Frame(self, borderwidth=1, relief="solid")
        self.panel_info.grid(row=0, column=0, padx=3, pady=3, sticky="nsew")

        self.lb_infotitle = Label(self.panel_info, text = _L["BAR_PROJINFO"], background="white")
        self.lb_infotitle.grid(row=0, column=0, columnspan=2, padx=3, pady=3, sticky="nsew")

        self.lb_fcs_indicatif = Label(self.panel_info, text = _L["BAR_FCS"])
        self.lb_fcs_indicatif.grid(row=1, column=0, padx=3, pady=3)
        self.lb_fcs = Label(self.panel_info, text = _L["BAR_NONE"])
        self.lb_fcs.grid(row=1, column=1, padx=3, pady=3)

        self.lb_scs_indicatif = Label(self.panel_info, text = _L["BAR_SCS"])
        self.lb_scs_indicatif.grid(row=2, column=0, padx=3, pady=3)
        self.lb_scs = Label(self.panel_info, text = _L["BAR_NONE"])
        self.lb_scs.grid(row=2, column=1, padx=3, pady=3)

        self.lb_grid_indicatif = Label(self.panel_info, text = _L["BAR_GRID"])
        self.lb_grid_indicatif.grid(row=3, column=0, padx=3, pady=3)
        self.lb_grid = Label(self.panel_info, text = _L["BAR_NONE"])
        self.lb_grid.grid(row=3, column=1, padx=3, pady=3)

        self.lb_net_indicatif = Label(self.panel_info, text = _L["BAR_RNET"])
        self.lb_net_indicatif.grid(row=4, column=0, padx=3, pady=3)
        self.lb_net = Label(self.panel_info, text = _L["BAR_NONE"])
        self.lb_net.grid(row=4, column=1, padx=3, pady=3)

        self.lb_veh_indicatif = Label(self.panel_info, text = _L["BAR_VEH"])
        self.lb_veh_indicatif.grid(row=5, column=0, padx=3, pady=3)
        self.lb_veh = Label(self.panel_info, text = _L["BAR_NONE"])
        self.lb_veh.grid(row=5, column=1, padx=3, pady=3)

        self.lb_plg_indicatif = Label(self.panel_info, text = _L["BAR_PLG"])
        self.lb_plg_indicatif.grid(row=6, column=0, padx=3, pady=3)
        self.lb_plg = Label(self.panel_info, text = _L["BAR_NONE"])
        self.lb_plg.grid(row=6, column=1, padx=3, pady=3)

        self.lb_cfg_indicatif = Label(self.panel_info, text = _L["BAR_SUMO"])
        self.lb_cfg_indicatif.grid(row=7, column=0, padx=3, pady=3)
        self.lb_cfg = Label(self.panel_info, text = _L["BAR_NONE"])
        self.lb_cfg.grid(row=7, column=1, padx=3, pady=3)

        self.lb_taz_indicatif = Label(self.panel_info, text = _L["BAR_TAZ"])
        self.lb_taz_indicatif.grid(row=8, column=0, padx=3, pady=3)
        self.lb_taz = Label(self.panel_info, text = _L["BAR_NONE"])
        self.lb_taz.grid(row=8, column=1, padx=3, pady=3)

        self.lb_taz_type_indicatif = Label(self.panel_info, text = _L["BAR_TAZTYPE"])
        self.lb_taz_type_indicatif.grid(row=9, column=0, padx=3, pady=3)
        self.lb_taz_type = Label(self.panel_info, text = _L["BAR_NONE"])
        self.lb_taz_type.grid(row=9, column=1, padx=3, pady=3)

        self.lb_py_indicatif = Label(self.panel_info, text = _L["BAR_ADDON"])
        self.lb_py_indicatif.grid(row=10, column=0, padx=3, pady=3)
        self.lb_py = Label(self.panel_info, text = _L["BAR_NONE"])
        self.lb_py.grid(row=10, column=1, padx=3, pady=3)

        self.lb_osm_indicatif = Label(self.panel_info, text = _L["BAR_OSM"])
        self.lb_osm_indicatif.grid(row=11, column=0, padx=3, pady=3)
        self.lb_osm = Label(self.panel_info, text = _L["BAR_NONE"])
        self.lb_osm.grid(row=11, column=1, padx=3, pady=3)

        self.lb_poly_indicatif = Label(self.panel_info, text = _L["BAR_POLY"])
        self.lb_poly_indicatif.grid(row=12, column=0, padx=3, pady=3)
        self.lb_poly = Label(self.panel_info, text = _L["BAR_NONE"])
        self.lb_poly.grid(row=12, column=1, padx=3, pady=3)

        self.lb_poi_indicatif = Label(self.panel_info, text = _L["BAR_POI"])
        self.lb_poi_indicatif.grid(row=13, column=0, padx=3, pady=3)
        self.lb_poi = Label(self.panel_info, text = _L["BAR_NONE"])
        self.lb_poi.grid(row=13, column=1, padx=3, pady=3)

        self.lb_cscsv_indicatif = Label(self.panel_info, text = _L["BAR_CSCSV"])
        self.lb_cscsv_indicatif.grid(row=14, column=0, padx=3, pady=3)
        self.lb_cscsv = Label(self.panel_info, text = _L["BAR_NONE"])
        self.lb_cscsv.grid(row=14, column=1, padx=3, pady=3)

        self.tabs = Notebook(self)
        self.tabs.grid(row=0, column=1, padx=3, pady=3, sticky="nsew")

        self.tab_sim = Frame(self.tabs)
        self.sim_time = LabelFrame(self.tab_sim, text=_L["SIM_BASIC"])
        self.sim_time.pack(fill="x", expand=False)
        self.lb_start = Label(self.sim_time, text=_L["SIM_BEGT"])
        self.lb_start.grid(row=0, column=0, padx=3, pady=3, sticky="w")
        self.entry_start = Entry(self.sim_time)
        self.entry_start.insert(0, "0")
        self.entry_start.grid(row=0, column=1, padx=3, pady=3, sticky="w")
        self.lb_end = Label(self.sim_time, text=_L["SIM_ENDT"])
        self.lb_end.grid(row=1, column=0, padx=3, pady=3, sticky="w")
        self.entry_end = Entry(self.sim_time)
        self.entry_end.insert(0, "172800")
        self.entry_end.grid(row=1, column=1, padx=3, pady=3, sticky="w")
        self.lb_step = Label(self.sim_time, text=_L["SIM_STEP"])
        self.lb_step.grid(row=2, column=0, padx=3, pady=3, sticky="w")
        self.entry_step = Entry(self.sim_time)
        self.entry_step.insert(0, "10")
        self.entry_step.grid(row=2, column=1, padx=3, pady=3, sticky="w")
        self.lb_seed = Label(self.sim_time, text=_L["SIM_SEED"])
        self.lb_seed.grid(row=3, column=0, padx=3, pady=3, sticky="w")
        self.entry_seed = Entry(self.sim_time)
        self.entry_seed.insert(0, "0")
        self.entry_seed.grid(row=3, column=1, padx=3, pady=3, sticky="w")
        self.ralgo = StringVar(self, "CH")
        self.lb_route_algo = Label(self.sim_time, text=_L["SIM_ROUTE_ALGO"])
        self.lb_route_algo.grid(row=4, column=0, padx=3, pady=3, sticky="w")
        self.combo_ralgo = Combobox(self.sim_time, textvariable=self.ralgo, values=["dijkstra", "astar", "CH", "CHWrapper"])
        self.combo_ralgo.grid(row=4, column=1, padx=3, pady=3, sticky="w")

        self.sim_load_last_state = BooleanVar(self, False)
        self.sim_cb_load_last_state = Checkbutton(self.sim_time, text=_L["SIM_LOAD_LAST_STATE"], variable=self.sim_load_last_state)
        self.sim_cb_load_last_state.grid(row=0, column=2, padx=3, pady=3, sticky="w")
        self.sim_save_on_abort = BooleanVar(self, False)
        self.sim_cb_save_on_abort = Checkbutton(self.sim_time, text=_L["SIM_SAVE_ON_ABORT"], variable=self.sim_save_on_abort)
        self.sim_cb_save_on_abort.grid(row=1, column=2, padx=3, pady=3, sticky="w")
        self.sim_save_on_finish = BooleanVar(self, False)
        self.sim_cb_save_on_finish = Checkbutton(self.sim_time, text=_L["SIM_SAVE_ON_FINISH"], variable=self.sim_save_on_finish)
        self.sim_cb_save_on_finish.grid(row=2, column=2, padx=3, pady=3, sticky="w")
        self.sim_copy_state = BooleanVar(self, False)
        self.sim_cb_copy_state = Checkbutton(self.sim_time, text=_L["SIM_COPY_STATE"], variable=self.sim_copy_state)
        self.sim_cb_copy_state.grid(row=3, column=2, padx=3, pady=3, sticky="w")
        self.sim_static_route = BooleanVar(self, False)
        self.sim_cb_static_route = Checkbutton(self.sim_time, text=_L["SIM_STATIC_ROUTE"], variable=self.sim_static_route)
        self.sim_cb_static_route.grid(row=4, column=2, padx=3, pady=3, sticky="w")

        self.sim_plugins = LabelFrame(self.tab_sim, text=_L["SIM_PLUGIN"])
        self.sim_plglist = PluginEditor(self.sim_plugins, self.__OnPluginEnabledSet)
        self.sim_plglist.pack(fill="both", expand=True)
        self.sim_plugins.pack(fill="x", expand=False)
        self.sim_plglist.setOnSave(self.savePlugins())
        self.sim_plglist.AfterFunc = self.__OnPluginEnabledSet

        self.sim_statistic = LogItemPad(self.tab_sim, _L["SIM_STAT"],self.sim_plglist.sta_pool)
        self.sim_statistic["ev"] = False
        self.sim_statistic.pack(fill="x", expand=False)
        self.__OnPluginEnabledSet()

        self.sim_btn = Button(self.tab_sim, text=_L["SIM_START"], command=self.simulate)
        self.sim_btn.pack(anchor="w", padx=3, pady=3)
        self.tabs.add(self.tab_sim, text=_L["TAB_SIM"])

        self.tab_CsCsv = Frame(self.tabs)
        self.CsCsv_editor = CSCSVEditor(self.tab_CsCsv, self.CSCSVDownloadWorker)
        self.CsCsv_editor.pack(fill="both", expand=True)
        self.tabs.add(self.tab_CsCsv, text=_L["TAB_CSCSV"])

        self.tab_FCS = Frame(self.tabs)
        self.FCS_editor = CSEditorGUI(self.tab_FCS, self.generateCS, False)
        self.FCS_editor.pack(fill="both", expand=True)
        self.tabs.add(self.tab_FCS, text=_L["TAB_FCS"])

        self.tab_SCS = Frame(self.tabs)
        self.SCS_editor = CSEditorGUI(self.tab_SCS, self.generateCS, True)
        self.SCS_editor.pack(fill="both", expand=True)
        self.tabs.add(self.tab_SCS, text=_L["TAB_SCS"])

        self.tab_Net = Frame(self.tabs)
        self.cv_net = NetworkPanel(self.tab_Net)
        self.cv_net.pack(fill=BOTH, expand=True)
        self.panel_net = LabelFrame(self.tab_Net, text=_L["RNET_TITLE"])
        self.lb_gridsave = Label(self.panel_net, text=_L["NOT_OPEN"])
        self.lb_gridsave.pack(side='left',padx=3,pady=3, anchor='w')
        def on_saved_changed(saved:bool):
            if saved:
                self.lb_gridsave.config(text=_L["SAVED"],foreground="green")
            else:
                self.lb_gridsave.config(text=_L["UNSAVED"],foreground="red")
        self.cv_net.save_callback = on_saved_changed
        self.btn_savegrid = Button(self.panel_net, text=_L["SAVE_GRID"], command=self.save)
        self.btn_savegrid.pack(side='left',padx=3,pady=3, anchor='w')
        self.lb_puvalues = Label(self.panel_net, text=_L["PU_VALS"].format('Null','Null'))
        self.lb_puvalues.pack(side='left',padx=3,pady=3, anchor='w')
        self.btn_savenetfig = Button(self.panel_net, text=_L["RNET_SAVE"], command=self.netsave)
        self.btn_savenetfig.pack(side="right", padx=3, pady=3, anchor="e")
        self.btn_draw = Button(self.panel_net, text=_L["RNET_DRAW"], command=self.draw)
        self.btn_draw.pack(side="right", padx=3, pady=3, anchor="e")
        self.entry_Ledges = Entry(self.panel_net)
        self.entry_Ledges.pack(side="right", padx=3, pady=3, anchor="e")
        self.lb_Ledges = Label(self.panel_net, text=_L["RNET_EDGES"])
        self.lb_Ledges.pack(side="right", padx=3, pady=3, anchor="e")
        
        self.panel_net.pack(fill="x", expand=False, anchor="s")
        self.tabs.add(self.tab_Net, text=_L["TAB_RNET"])

        self.tab_Veh = Frame(self.tabs)
        self.fr_veh_basic = LabelFrame(self.tab_Veh,text=_L["VEH_BASIC"])
        self.fr_veh_basic.pack(fill="x", expand=False)
        self.lb_carcnt = Label(self.fr_veh_basic, text=_L["VEH_COUNT"])
        self.lb_carcnt.grid(row=0, column=0, padx=3, pady=3, sticky="w")
        self.entry_carcnt = Entry(self.fr_veh_basic)
        self.entry_carcnt.insert(0, "10000")
        self.entry_carcnt.grid(row=0, column=1, padx=3, pady=3, sticky="w")
        self.lb_daycnt = Label(self.fr_veh_basic, text=_L["VEH_DAY_COUNT"])
        self.lb_daycnt.grid(row=1, column=0, padx=3, pady=3, sticky="w")
        self.entry_daycnt = Entry(self.fr_veh_basic)
        self.entry_daycnt.insert(0, "7")
        self.entry_daycnt.grid(row=1, column=1, padx=3, pady=3, sticky="w")
        self.lb_v2gprop = Label(self.fr_veh_basic, text=_L["VEH_V2GPROP"])
        self.lb_v2gprop.grid(row=2, column=0, padx=3, pady=3, sticky="w")
        self.entry_v2gprop = Entry(self.fr_veh_basic)
        self.entry_v2gprop.insert(0, "1.00")
        self.entry_v2gprop.grid(row=2, column=1, padx=3, pady=3, sticky="w")
        self.lb_v2gprop_info = Label(self.fr_veh_basic, text=_L["VEH_V2GPROP_INFO"])
        self.lb_v2gprop_info.grid(row=2, column=2, padx=3, pady=3, sticky="w")
        self.lb_carseed = Label(self.fr_veh_basic, text=_L["VEH_SEED"])
        self.lb_carseed.grid(row=3, column=0, padx=3, pady=3, sticky="w")
        self.entry_carseed = Entry(self.fr_veh_basic)
        self.entry_carseed.insert(0, "0")
        self.entry_carseed.grid(row=3, column=1, padx=3, pady=3, sticky="w")

        self.veh_pars = PropertyPanel(self.tab_Veh, {
            "Omega":repr(PDUniform(5.0, 10.0)),
            "KRel":repr(PDUniform(1.0, 1.2)),
            "KSC":repr(PDUniform(0.4, 0.6)),
            "KFC":repr(PDUniform(0.2, 0.25)),
            "KV2G":repr(PDUniform(0.65, 0.75)),
        }, ConfigItemDict((
            ConfigItem("Omega", EditMode.PDFUNC, _L["VEH_OMEGA_DESC"]),
            ConfigItem("KRel", EditMode.PDFUNC, _L["VEH_KREL_DESC"]),
            ConfigItem("KSC", EditMode.PDFUNC, _L["VEH_KSC_DESC"]),
            ConfigItem("KFC", EditMode.PDFUNC, _L["VEH_KFC_DESC"]),
            ConfigItem("KV2G", EditMode.PDFUNC, _L["VEH_KV2G_DESC"]),
        )))
        self.veh_pars.pack(fill="x", expand=False, pady=10)

        self.veh_gen_src = IntVar(self, 0)
        self.fr_veh_src = LabelFrame(self.tab_Veh,text=_L["VEH_ODSRC"])
        self.fr_veh_src.pack(fill="x", expand=False)
        self.rb_veh_src0 = Radiobutton(self.fr_veh_src, text=_L["VEH_ODAUTO"], value=0, variable=self.veh_gen_src)
        self.rb_veh_src0.grid(row=0, column=0, padx=3, pady=3, sticky="w")
        self.rb_veh_src1 = Radiobutton(self.fr_veh_src, text=_L["VEH_ODTYPE"], value=1, variable=self.veh_gen_src)
        self.rb_veh_src1.grid(row=1, column=0, padx=3, pady=3, sticky="w")
        self.rb_veh_src2 = Radiobutton(self.fr_veh_src, text=_L["VEH_ODPOLY"], value=2, variable=self.veh_gen_src)
        self.rb_veh_src2.grid(row=2, column=0, padx=3, pady=3, sticky="w")

        self.veh_route_cache = IntVar(self, 0)
        self.fr_veh_route_cache = LabelFrame(self.tab_Veh,text=_L["VEH_ROUTE_CACHE"])
        self.fr_veh_route_cache.pack(fill="x", expand=False)
        self.rb_veh_route_cache0 = Radiobutton(self.fr_veh_route_cache, text=_L["VEH_ROUTE_NO_CACHE"], value=0, variable=self.veh_route_cache)
        self.rb_veh_route_cache0.grid(row=0, column=0, padx=3, pady=3, sticky="w")
        self.rb_veh_route_cache1 = Radiobutton(self.fr_veh_route_cache, text=_L["VEH_ROUTE_RUNTIME_CACHE"], value=1, variable=self.veh_route_cache)
        self.rb_veh_route_cache1.grid(row=1, column=0, padx=3, pady=3, sticky="w")
        self.rb_veh_route_cache2 = Radiobutton(self.fr_veh_route_cache, text=_L["VEH_ROUTE_STATIC_CACHE"], value=2, variable=self.veh_route_cache)
        self.rb_veh_route_cache2.grid(row=2, column=0, padx=3, pady=3, sticky="w")

        self.btn_genveh = Button(self.tab_Veh, text=_L["VEH_GEN"], command=self.generateVeh)
        self.btn_genveh.pack(anchor="w")
        self.tabs.add(self.tab_Veh, text=_L["TAB_VEH"])

        self.sbar = Label(self, text=_L["STA_READY"], anchor="w")
        self.sbar.grid(row=1, column=0, columnspan=2, sticky="ew")
        self.protocol("WM_DELETE_WINDOW", self.onDestroy)

        if self.folder != "":
            self.after(200, self._load)
    
    def netsave(self):
        ret = filedialog.asksaveasfilename(
            defaultextension=".eps",
            filetypes=[
                (_L["EXT_EPS"],".eps"),             
            ]
        )
        if ret == "": return
        try:
            self.cv_net.savefig(ret)
        except RuntimeError:
            showerr(_L["RNET_SAVE_ERR"])
            return
        self.setStatus("Figure saved")

    def veh_par_edit(self, var:StringVar):
        def _f():
            e = PDFuncEditor(var)
            e.wait_window()
        return _f

    @property
    def saved(self):
        return self.sim_plglist.saved and self.FCS_editor.saved and self.SCS_editor.saved and self.cv_net.saved
    
    def save(self):
        if not self.sim_plglist.saved: self.sim_plglist.save()
        if not self.FCS_editor.saved: self.FCS_editor.save()
        if not self.SCS_editor.saved: self.SCS_editor.save()
        if not self.cv_net.saved: self.saveNet()
    
    def get_default_grid_path(self) -> str:
        return str(Path(self.folder) / Path(self.folder).name) + ".grid.xml"
    
    def get_default_roadnet_path(self) -> str:
        return str(Path(self.folder) / Path(self.folder).name) + ".net.xml"
    
    def saveNet(self):
        assert self.state is not None
        if self.state.grid:
            gpath = self.state.grid
            os.remove(gpath)
            if not gpath.lower().endswith(".xml"):
                gpath = self.get_default_grid_path()
        else:
            gpath = self.get_default_grid_path()
        if self.state.net:
            npath = self.state.net
            if not npath.lower().endswith(".xml"):
                npath = self.get_default_roadnet_path()
        else:
            npath = self.get_default_roadnet_path()
        self.cv_net.save(gpath, npath)
        
    def onDestroy(self):
        if not self.saved:
            ret = MB.askyesnocancel(_L["MB_INFO"], _L["MB_EXIT_SAVE"])
            if ret is None: return
            if ret: self.save()
        self.destroy()

    def simulate(self):
        if not self.__checkFolderOpened():
            return
        try:
            start = int(self.entry_start.get())
            end = int(self.entry_end.get())
            step = int(self.entry_step.get())
            seed = int(self.entry_seed.get())
        except:
            showerr("Invalid time")
            return
        if not self.state:
            showerr("No project loaded")
            return
        if "scs" not in self.state:
            showerr("No SCS loaded")
            return
        if "fcs" not in self.state:
            showerr("No FCS loaded")
            return
        if "veh" not in self.state:
            showerr("No vehicles loaded")
            return
        logs = []
        for x in ("fcs","scs","ev","gen","bus","line","pvw","ess"):
            if self.sim_statistic[x]:
                logs.append(x)
        if not logs:
            showerr(_L["NO_STA"])
            return
        if not self.saved:
            if not MB.askyesno(_L["MB_INFO"],_L["MB_SAVE_AND_SIM"]): return
            self.save()
        
        # If PDN is enabled, check if cvxpy and ecos are installed
        if self.sim_plglist.is_enabled("pdn"):
            try:
                import cvxpy # type: ignore
                import ecos # type: ignore
            except ImportError as e:
                if MB.askyesno(_L["MB_INFO"], _L["MB_PDN_REQUIRED"]):
                    os.system(f"{sys.executable} -m pip install cvxpy ecos")
                else:
                    return
        
        # Save preference
        vcfg = V2SimConfig()
        vcfg.start_time = start
        vcfg.end_time = end
        vcfg.traffic_step = step
        vcfg.seed = seed
        vcfg.load_state = self.sim_load_last_state.get()
        vcfg.save_state_on_abort = self.sim_save_on_abort.get()
        vcfg.save_state_on_finish = self.sim_save_on_finish.get()
        vcfg.copy_state = self.sim_copy_state.get()
        vcfg.force_caching = self.sim_static_route.get()
        vcfg.routing_method = self.ralgo.get()
        vcfg.stats = logs
        vcfg.save(self.folder + "/preference.v2simcfg")
            
        commands = [sys.executable, "sim_single.py",
                    "-d", '"'+self.folder+'"', 
                    "-b", str(start), 
                    "-e", str(end), 
                    "-l", str(step), 
                    "-log", ','.join(logs),
                    "-seed", str(seed),
                    "--load-last-state" if self.sim_load_last_state.get() else "",
                    "--save-on-abort" if self.sim_save_on_abort.get() else "",
                    "--save-on-finish" if self.sim_save_on_finish.get() else "",
                    "--route-algo", self.ralgo.get(),
                    "--static-routing" if self.sim_static_route.get() else "",
                    "--copy-state" if self.sim_copy_state.get() else "",
                ]
        
        self.destroy()
        try:
            os.system(" ".join(commands))
        except KeyboardInterrupt:
            pass
        

    def savePlugins(self):
        def _save(data:List[tuple]):
            if not self.__checkFolderOpened():
                return False
            self.setStatus(_L["SAVE_PLG"])
            if self.state and "plg" in self.state:
                filename = self.state["plg"]
            else:
                filename = self.folder + "/plugins.plg.xml"
            try:
                rt = ET.Element("root")
                with open(filename, "w") as f:
                    f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
                    for d in data:
                        attr = {"interval":str(d[1]), "enabled":str(d[2])}
                        attr.update(eval(d[4]))
                        for k,v in attr.items():
                            if not isinstance(v, str):
                                attr[k] = str(v)
                        e = ET.Element(d[0], attr)
                        if d[3] != ALWAYS_ONLINE:
                            ol = ET.Element("online")
                            lst = eval(d[3])
                            for r in lst:
                                ol.append(ET.Element("item", {"btime":str(r[0]), "etime":str(r[1])}))
                            e.append(ol)
                        rt.append(e)
                    f.write(ET.tostring(rt, "unicode", ).replace("><", ">\n<"))
                pass
            except Exception as e:
                self.setStatus(f"Error: {e}")
                traceback.print_exc()
                showerr(f"Error saving plugins: {e}")
                return False
            self.setStatus("Plugins saved")
            return True
        return _save
    
    def __checkFolderOpened(self):
        if not self.folder:
            showerr(_L["PROJ_NO_OPEN"])
            return False
        return True
    
    def _load_tg(self, after:OAfter=None):
        try:
            self.tg = TrafficGenerator(self.folder)
        except Exception as e:
            traceback.print_exc()
            showerr(f"Error loading traffic generator: {e}")
            self.tg = None
        else:
            if after: after()
    
    def _load(self, loads:Optional[List[str]] = None, async_:bool = True):
        if not self.folder:
            showerr("No project folder selected")
            return
        if loads is None: loads = [
            LOAD_GEN, LOAD_FCS, LOAD_SCS, LOAD_CSCSV, LOAD_NET, LOAD_PLG
        ]
        self._ldfrm = LoadingBox(loads, self._Q)
        self.update()
        self.after(100, self.__load_part2, set(loads), async_)
    
    def __load_part2(self, loads:Set[str], async_:bool):
        self.state = res = DetectFiles(self.folder)
        self.title(f"{_L['TITLE']} - {Path(self.folder).name}")
        self.update()

        # Check if grid exists
        if not res.grid: 
            with open(self.get_default_grid_path(),"w") as f:
                f.write(DEFAULT_GRID)
            self.state = res = DetectFiles(self.folder)
        
        self.update()
        
        # Load traffic generator
        if LOAD_GEN in loads:
            self._Q.submit("TrafficGenLoaded", self._load_tg)

        self.update()

        # Load FCS
        if LOAD_FCS in loads:
            self._load_fcs(lambda: self._ldfrm.setText(LOAD_FCS, _L['DONE']))

        self.update()

        # Load SCS
        if LOAD_SCS in loads:
            self._load_scs(lambda: self._ldfrm.setText(LOAD_SCS, _L['DONE']))
        
        self.update()

        # Load CSCSV
        if LOAD_CSCSV in loads:
            self._load_cscsv(lambda: self._ldfrm.setText(LOAD_CSCSV, _L['DONE']))
        
        self.update()

        # Load plugins
        if LOAD_PLG in loads:
            self._load_plugins()
            self._ldfrm.setText(LOAD_PLG,_L['DONE'])
        
        self.update()

        self.rb_veh_src2.configure(state="normal" if "poly" in res else "disabled")
        self.rb_veh_src1.configure(state="normal" if "taz" in res else "disabled")
        
        self.state = res = DetectFiles(self.folder)

        self.update()
        
        if LOAD_NET in loads:
            self.cv_net.clear()
            self._load_network(self.tabs.select(),
                lambda: self._ldfrm.setText(LOAD_NET, _L['DONE']))
        
        self.update()

        def setText(lb:Label, itm:str, must:bool = False):
            if itm in res:
                lb.config(text=Path(res[itm]).name, foreground="black")
            else:
                lb.config(text="None", foreground="red" if must else "black")
        
        setText(self.lb_fcs, "fcs", True)
        setText(self.lb_scs, "scs", True)
        setText(self.lb_grid, "grid")
        setText(self.lb_net, "net", True)
        setText(self.lb_veh, "veh", True)
        setText(self.lb_plg, "plg")
        setText(self.lb_cfg, "cfg")
        setText(self.lb_taz, "taz")
        setText(self.lb_py, "py")
        setText(self.lb_taz_type, "taz_type")
        setText(self.lb_osm, "osm")
        setText(self.lb_poly, "poly")
        setText(self.lb_poi, "poi")
        setText(self.lb_cscsv, "cscsv")

        self.update()

        if self.state.pref:
            vcfg = V2SimConfig.load(self.state.pref)
            self.entry_start.delete(0, END)
            self.entry_start.insert(0, str(vcfg.start_time))
            self.entry_end.delete(0, END)
            self.entry_end.insert(0, str(vcfg.end_time))
            self.entry_step.delete(0, END)
            self.entry_step.insert(0, str(vcfg.traffic_step))
            self.entry_seed.delete(0, END)
            self.entry_seed.insert(0, str(vcfg.seed))
            self.ralgo.set(vcfg.routing_method)
            self.sim_save_on_finish.set(vcfg.save_state_on_finish)
            self.sim_save_on_abort.set(vcfg.save_state_on_abort)
            self.sim_load_last_state.set(vcfg.load_state)
            self.sim_copy_state.set(vcfg.copy_state)
            self.sim_static_route.set(vcfg.force_caching)
            if vcfg.stats:
                for x in vcfg.stats:
                    if x in self.sim_statistic:
                        self.sim_statistic[x] = True
                    else:
                        showerr(_L["UKN_STA_TYPE"].format(x, ', '.join(self.sim_statistic.keys())))
        self.update()

        self.setStatus(_L["STA_READY"])
        
        if len(loads) == 0: self._ldfrm.destroy()
    
    def _load_plugins(self):
        plg_set:Set[str] = set()
        plg_enabled_set:Set[str] = set()

        self.sim_plglist.clear()
        assert self.state is not None
        if self.state.plg:
            et = ReadXML(self.state.plg)
            if et is None:
                showerr(_L["ERR_LOAD_PLG"])
                return
            rt = et.getroot()
            if rt is None:
                showerr(_L["ERR_LOAD_PLG"])
                return
            for p in rt:
                try:
                    plg_type = self.sim_plglist.plg_pool.GetPluginType(p.tag.lower())
                except KeyError:
                    plg_list = ', '.join(self.sim_plglist.plg_pool.GetAllPlugins().keys())
                    showerr(_L["UKN_PLG_TYPE"].format(p.tag, plg_list))
                    continue
                assert issubclass(plg_type, PluginBase), "Plugin type is not a subclass of PluginBase"

                attr = plg_type.ElemShouldHave().default_value_dict()
                plg_set.add(p.tag.lower())

                # Check online attribute
                olelem = p.find("online")
                if olelem is not None: ol_str = RangeList(olelem)
                else: ol_str = ALWAYS_ONLINE

                # Check enabled attribute
                enabled = p.attrib.pop("enabled", SIM_YES)
                if enabled.upper() != SIM_NO:
                    enabled = SIM_YES
                    plg_enabled_set.add(p.tag.lower())
                
                # Check interval attribute
                intv = p.attrib.pop("interval")
                attr.update(p.attrib)
                self.sim_plglist.add(p.tag, intv, enabled, ol_str, attr)

        # Check if PDN exists
        if "pdn" not in plg_set:
            pdn_attr_default = PluginPDN.ElemShouldHave().default_value_dict()
            self.sim_plglist.add("pdn", 300, SIM_YES, ALWAYS_ONLINE, pdn_attr_default)
            plg_set.add("pdn")
            plg_enabled_set.add("pdn")
        
        # Check if V2G exists
        if "v2g" not in plg_set:
            self.sim_plglist.add("v2g", 300, SIM_YES, ALWAYS_ONLINE, {})
        if not self.state.plg:
            self.sim_plglist.save()
        
        self.__OnPluginEnabledSet()
        
    def _load_fcs(self, afterx:OAfter = None):
        assert self.state is not None
        def after():
            assert self.state is not None
            v = "fcs" in self.state
            self.sim_statistic["fcs"]=v
            self.sim_statistic.setEnabled("fcs", v)
            self.FCS_editor.setPoly("poly" in self.state)
            self.FCS_editor.setCSCSV("cscsv" in self.state)
            if afterx: afterx()
        if self.state.fcs:
            self.FCS_editor._Q.setcallback("loaded", after)
            self.FCS_editor.load(self.state.fcs)
        else:
            self.FCS_editor.clear()
            after()
        
    def _load_scs(self, afterx:OAfter=None):
        assert self.state is not None
        def after():
            assert self.state is not None
            v = "scs" in self.state
            self.sim_statistic["scs"] = v
            self.sim_statistic.setEnabled("scs", v)
            self.SCS_editor.setPoly("poly" in self.state)
            self.SCS_editor.setCSCSV("cscsv" in self.state)
            if afterx: afterx()
        if self.state.scs:
            self.SCS_editor._Q.setcallback("loaded", after)
            self.SCS_editor.load(self.state.scs)
        else:
            self.SCS_editor.clear()
            after()

    def _load_cscsv(self, after:OAfter = None):
        assert self.state is not None
        if self.state.cscsv:
            if after:
                self.CsCsv_editor._Q.setcallback("loaded", after)
            self.CsCsv_editor.load(self.state.cscsv)
        else:
            self.CsCsv_editor.clear()
            if after: after()
    
    def _load_network(self, tab_ret, after:OAfter = None):
        if self.state and self.state.net:
            self.tabs.select(self.tab_Net)
            time.sleep(0.01)
            self.tabs.select(tab_ret)
            self.lb_gridsave.config(text=_L["SAVED"],foreground="green")
            
            assert self.state is not None and self.state.net is not None
            if self.state.grid:
                self.cv_net.setGrid(PowerGrid.fromFile(self.state.grid))
            assert self.cv_net.Grid is not None
            self.lb_puvalues.configure(text=_L["PU_VALS"].format(self.cv_net.Grid.Ub,self.cv_net.Grid.Sb_MVA))

            def __el(state: FileDetectResult, after:OAfter=None):
                assert state.net is not None
                el = RoadNet.load(state.net)
                return el, after
            
            self._Q.submit("cvnetloaded", __el, self.state, after)

    def on_cvnet_loaded(self, el:RoadNet, after:OAfter=None):
        self.cv_net.setRoadNet(el, after = after)

    def openFolder(self):
        init_dir = Path("./cases")
        if not init_dir.exists(): init_dir.mkdir(parents=True, exist_ok=True)
        folder = filedialog.askdirectory(initialdir=str(init_dir),mustexist=True,title="Select project folder")
        if folder:
            self.folder = str(Path(folder))
            self._load()
    
    def generateCS(self, ctl:CSEditorGUI, cscsv_mode:int, **kwargs):
        if not self.tg:
            showerr("No traffic generator loaded")
            return
        self.setStatus("Generating CS...")
        if cscsv_mode == 0:
            cs_file = ""
            poly_file = ""
        elif cscsv_mode == 1:
            cs_file = self.state.cscsv if self.state else ""
            poly_file = ""
        else:
            cs_file = ""
            poly_file = self.state.poly if self.state else ""
        use_grid = kwargs.pop("use_grid", False)
        assert self.state is not None
        if use_grid:
            if self.state.grid is None:
                showerr("No grid loaded")
                return
            kwargs["grid_file"] = self.state.grid
        kwargs["cs_file"] = cs_file
        kwargs["poly_file"] = poly_file

        def work(ctl, **kwargs):
            try:
                if not self.tg: return
                self.tg._CS(**kwargs)
                if kwargs["mode"] == "fcs":
                    self._load([LOAD_FCS, LOAD_GEN])
                else:
                    self._load([LOAD_SCS, LOAD_GEN])
                return ctl, None
            except Exception as e:
                print(f"\nError generating CS: {e}")
                traceback.print_exc()
                return ctl, e
            
        self._Q.submit("CSGenDone", work, ctl, **kwargs)   
    
    def generateVeh(self):
        if not self.tg:
            showerr(_L["MSG_NO_TRAFFIC_GEN"])
            return
        if not self.__checkFolderOpened(): return
        self.setStatus(_L["STA_GEN_VEH"])
        try:
            carcnt = int(self.entry_carcnt.get())
        except:
            showerr(_L["MSG_INVALID_VEH_CNT"])
            return
        try:
            carseed = int(self.entry_carseed.get())
        except:
            showerr(_L["MSG_INVALID_VEH_SEED"])
            return
        try:
            day_count = int(self.entry_daycnt.get())
        except:
            showerr(_L["MSG_INVALID_VEH_DAY_CNT"])
            return
        try:
            pars = self.veh_pars.getAllData()
            new_pars = {
                "v2g_prop":float(self.entry_v2gprop.get()),
                "omega":eval(pars["Omega"]),
                "krel":eval(pars["KRel"]),
                "ksc":eval(pars["KSC"]),
                "kfc":eval(pars["KFC"]),
                "kv2g":eval(pars["KV2G"]),
            }
        except:
            showerr("Invalid Vehicle parameters")
            return
        if self.veh_gen_src.get() == 0:
            mode = TripsGenMode.AUTO
        elif self.veh_gen_src.get() == 1:
            mode = TripsGenMode.TYPE
        else:
            mode = TripsGenMode.POLY
        route_cache = RoutingCacheMode(self.veh_route_cache.get())
        self.btn_genveh.config(state = DISABLED)

        def work() -> Optional[Exception]:
            try:
                assert self.tg
                self.tg.EVTrips(carcnt, carseed, day_count, mode = mode, route_cache = route_cache, **new_pars)
                self._load([])
                return None
            except Exception as e:
                return e
        
        self._Q.submit("VehGenDone", work)

    def draw(self):
        if not self.__checkFolderOpened(): return
        self.cv_net.UnlocateAllEdges()
        s = set(x.strip() for x in self.entry_Ledges.get().split(','))
        self.cv_net.LocateEdges(s)

    def CSCSVDownloadWorker(self):
        if not self.__checkFolderOpened(): return
        self.setStatus("Downloading CS CSV...")
        key = self.CsCsv_editor.entry_amapkey.get()
        def work():
            try:
                csQuery(self.folder,"",key,True)
                self._load([LOAD_CSCSV])
                return None
            except Exception as e:
                return e
        
        self._Q.submit("CSCSVDownloadDone", work)
        
    def setStatus(self, text:str):
        self.sbar.config(text=text)

    def _win(self):
        self.title(_L["TITLE"])

if __name__ == "__main__":
    win = MainBox()
    win.mainloop()